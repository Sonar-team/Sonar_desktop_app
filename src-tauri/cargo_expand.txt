#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod cli {
    use clap::Parser;
    use colored::Colorize;
    #[command(author, version, about, long_about = None)]
    pub struct Args {
        /// Name the output name of the csv
        #[arg(short, long, default_value = "output.csv")]
        output: String,
        #[arg(short, long, default_value = "all")]
        /// give the interface name to scan
        interface: String,
        /// Give the scan time
        #[arg(short, long, default_value_t = 0)]
        time: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications, clippy::redundant_locals)]
    impl clap::Parser for Args {}
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::CommandFactory for Args {
        fn command<'b>() -> clap::Command {
            let __clap_app = clap::Command::new("sonar_desktop_app");
            <Self as clap::Args>::augment_args(__clap_app)
        }
        fn command_for_update<'b>() -> clap::Command {
            let __clap_app = clap::Command::new("sonar_desktop_app");
            <Self as clap::Args>::augment_args_for_update(__clap_app)
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::FromArgMatches for Args {
        fn from_arg_matches(
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn from_arg_matches_mut(
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            #![allow(deprecated)]
            let v = Args {
                output: __clap_arg_matches
                    .remove_one::<String>("output")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: output",
                    ))?,
                interface: __clap_arg_matches
                    .remove_one::<String>("interface")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: interface",
                    ))?,
                time: __clap_arg_matches
                    .remove_one::<u64>("time")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: time",
                    ))?,
            };
            ::std::result::Result::Ok(v)
        }
        fn update_from_arg_matches(
            &mut self,
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn update_from_arg_matches_mut(
            &mut self,
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            #![allow(deprecated)]
            if __clap_arg_matches.contains_id("output") {
                #[allow(non_snake_case)]
                let output = &mut self.output;
                *output = __clap_arg_matches
                    .remove_one::<String>("output")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: output",
                    ))?;
            }
            if __clap_arg_matches.contains_id("interface") {
                #[allow(non_snake_case)]
                let interface = &mut self.interface;
                *interface = __clap_arg_matches
                    .remove_one::<String>("interface")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: interface",
                    ))?;
            }
            if __clap_arg_matches.contains_id("time") {
                #[allow(non_snake_case)]
                let time = &mut self.time;
                *time = __clap_arg_matches
                    .remove_one::<u64>("time")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "The following required argument was not provided: time",
                    ))?;
            }
            ::std::result::Result::Ok(())
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::Args for Args {
        fn group_id() -> Option<clap::Id> {
            Some(clap::Id::from("Args"))
        }
        fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
            {
                let __clap_app = __clap_app
                    .group(
                        clap::ArgGroup::new("Args")
                            .multiple(true)
                            .args({
                                let members: [clap::Id; 3usize] = [
                                    clap::Id::from("output"),
                                    clap::Id::from("interface"),
                                    clap::Id::from("time"),
                                ];
                                members
                            }),
                    );
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("output")
                            .value_name("OUTPUT")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    String,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Name the output name of the csv")
                            .long_help(None)
                            .short('o')
                            .long("output")
                            .default_value("output.csv");
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("interface")
                            .value_name("INTERFACE")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    String,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("give the interface name to scan")
                            .long_help(None)
                            .short('i')
                            .long("interface")
                            .default_value("all");
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("time")
                            .value_name("TIME")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    u64,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Give the scan time")
                            .long_help(None)
                            .short('t')
                            .long("time")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: u64 = 0;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            });
                        let arg = arg;
                        arg
                    });
                __clap_app
                    .author("you")
                    .version("1.0.1")
                    .about("A Tauri App")
                    .long_about(None)
            }
        }
        fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
            {
                let __clap_app = __clap_app
                    .group(
                        clap::ArgGroup::new("Args")
                            .multiple(true)
                            .args({
                                let members: [clap::Id; 3usize] = [
                                    clap::Id::from("output"),
                                    clap::Id::from("interface"),
                                    clap::Id::from("time"),
                                ];
                                members
                            }),
                    );
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("output")
                            .value_name("OUTPUT")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    String,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Name the output name of the csv")
                            .long_help(None)
                            .short('o')
                            .long("output")
                            .default_value("output.csv");
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("interface")
                            .value_name("INTERFACE")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    String,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("give the interface name to scan")
                            .long_help(None)
                            .short('i')
                            .long("interface")
                            .default_value("all");
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("time")
                            .value_name("TIME")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::via_prelude::*;
                                let auto = ::clap_builder::builder::_AutoValueParser::<
                                    u64,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Give the scan time")
                            .long_help(None)
                            .short('t')
                            .long("time")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: u64 = 0;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            });
                        let arg = arg.required(false);
                        arg
                    });
                __clap_app
                    .author("you")
                    .version("1.0.1")
                    .about("A Tauri App")
                    .long_about(None)
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Args {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Args",
                "output",
                &self.output,
                "interface",
                &self.interface,
                "time",
                &&self.time,
            )
        }
    }
    pub fn get_args(args: &Args) -> (&String, &String, &u64) {
        (&args.output, &args.interface, &args.time)
    }
    pub fn print_banner() -> String {
        let banner = r"
    _________                           
   /   _____/ ____   ____ _____ _______ 
   \_____  \ /  _ \ /    \\__  \\_  __ \
   /        (  <_> )   |  \/ __ \|  | \/
  /_______  /\____/|___|  (____  /__|   
          \/            \/     \/          
   ";
        banner.green().to_string()
    }
}
pub mod get_interfaces {
    use pnet::datalink;
    use log::info;
    pub fn get_interfaces() -> Vec<String> {
        let interfaces = datalink::interfaces();
        {
            let lvl = ::log::Level::Info;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!("Fetching network interfaces"),
                    lvl,
                    &(
                        "sonar_desktop_app::get_interfaces",
                        "sonar_desktop_app::get_interfaces",
                        "src/get_interfaces/mod.rs",
                    ),
                    6u32,
                    ::log::__private_api::Option::None,
                );
            }
        };
        let mut names: Vec<String> = interfaces
            .iter()
            .map(|iface| { iface.name.clone() })
            .collect();
        let all = String::from("Toutes les interfaces");
        names.push(all);
        names
    }
}
pub mod save_packets {
    use crate::{
        sniff::capture_packet::layer_2_infos::PacketInfos, tauri_state::SonarState,
    };
    use csv::Writer;
    use serde::Serialize;
    use tauri::State;
    use thiserror::Error;
    pub enum MyError {
        #[error("IO Error: {0}")]
        IoError(String),
        #[error("CSV Error: {0}")]
        CsvError(String),
        #[error("UTF-8 Conversion Error: {0}")]
        Utf8Error(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MyError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MyError::IoError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IoError",
                        &__self_0,
                    )
                }
                MyError::CsvError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CsvError",
                        &__self_0,
                    )
                }
                MyError::Utf8Error(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Utf8Error",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for MyError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for MyError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                MyError::IoError(_0) => {
                    __formatter.write_fmt(format_args!("IO Error: {0}", _0.as_display()))
                }
                MyError::CsvError(_0) => {
                    __formatter
                        .write_fmt(format_args!("CSV Error: {0}", _0.as_display()))
                }
                MyError::Utf8Error(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("UTF-8 Conversion Error: {0}", _0.as_display()),
                        )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MyError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    MyError::IoError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MyError",
                            0u32,
                            "IoError",
                            __field0,
                        )
                    }
                    MyError::CsvError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MyError",
                            1u32,
                            "CsvError",
                            __field0,
                        )
                    }
                    MyError::Utf8Error(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MyError",
                            2u32,
                            "Utf8Error",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    struct PacketInfosCsv {
        mac_address_source: String,
        mac_address_destination: String,
        interface: String,
        ip_source: Option<String>,
        ip_destination: Option<String>,
        l_4_protocol: Option<String>,
        port_source: Option<String>,
        port_destination: Option<String>,
        count: u32,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PacketInfosCsv {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PacketInfosCsv",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mac_address_source",
                    &self.mac_address_source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mac_address_destination",
                    &self.mac_address_destination,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "interface",
                    &self.interface,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ip_source",
                    &self.ip_source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ip_destination",
                    &self.ip_destination,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "l_4_protocol",
                    &self.l_4_protocol,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "port_source",
                    &self.port_source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "port_destination",
                    &self.port_destination,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "count",
                    &self.count,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl PacketInfosCsv {
        fn from_packet_infos(packet: &PacketInfos, count: u32) -> Self {
            PacketInfosCsv {
                mac_address_source: packet.mac_address_source.clone(),
                mac_address_destination: packet.mac_address_destination.clone(),
                interface: packet.interface.clone(),
                ip_source: packet.layer_3_infos.ip_source.clone(),
                ip_destination: packet.layer_3_infos.ip_destination.clone(),
                l_4_protocol: packet.layer_3_infos.l_4_protocol.clone(),
                port_source: packet.layer_3_infos.layer_4_infos.port_source.clone(),
                port_destination: packet
                    .layer_3_infos
                    .layer_4_infos
                    .port_destination
                    .clone(),
                count,
            }
        }
    }
    struct PacketData<'a> {
        packet: &'a PacketInfos,
        count: u32,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for PacketData<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PacketData",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "packet",
                    &self.packet,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "count",
                    &self.count,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    pub fn cmd_save_packets_to_csv(
        file_path: String,
        state: State<SonarState>,
    ) -> Result<(), MyError> {
        let data = state.0.lock().unwrap();
        let mut wtr = Writer::from_path(file_path)
            .map_err(|e| MyError::IoError(e.to_string()))?;
        for (packet, count) in data.iter() {
            let packet_csv = PacketInfosCsv::from_packet_infos(packet, *count);
            wtr.serialize(packet_csv).map_err(|e| MyError::CsvError(e.to_string()))?;
        }
        wtr.flush().map_err(|e| MyError::IoError(e.to_string()))?;
        Ok(())
    }
}
pub mod sniff {
    pub(crate) mod capture_packet {
        use pnet::datalink::Channel::Ethernet;
        use pnet::datalink::{self, NetworkInterface};
        use pnet::packet::ethernet::EthernetPacket;
        use std::sync::mpsc;
        use std::thread;
        use log::{info, error};
        use tauri::{Manager, State};
        pub(crate) mod layer_2_infos {
            use std::fmt;
            use pnet::packet::ethernet::EthernetPacket;
            use layer_3_infos::{get_layer_3_infos, Layer3Infos};
            use serde::Serialize;
            pub(crate) mod layer_3_infos {
                use pnet::packet::{
                    arp::ArpPacket, ethernet::{EtherTypes::self, EthernetPacket},
                    ipv4::Ipv4Packet, ipv6::Ipv6Packet, vlan::VlanPacket, Packet,
                };
                mod layer_4_infos {
                    use pnet::packet::icmp::IcmpPacket;
                    use pnet::packet::icmpv6::Icmpv6Packet;
                    use pnet::packet::ip::{IpNextHeaderProtocol, IpNextHeaderProtocols};
                    use pnet::packet::tcp::TcpPacket;
                    use pnet::packet::udp::UdpPacket;
                    use serde::Serialize;
                    pub struct Layer4Infos {
                        pub port_source: Option<String>,
                        pub port_destination: Option<String>,
                    }
                    #[automatically_derived]
                    impl ::core::fmt::Debug for Layer4Infos {
                        #[inline]
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "Layer4Infos",
                                "port_source",
                                &self.port_source,
                                "port_destination",
                                &&self.port_destination,
                            )
                        }
                    }
                    #[automatically_derived]
                    impl ::core::default::Default for Layer4Infos {
                        #[inline]
                        fn default() -> Layer4Infos {
                            Layer4Infos {
                                port_source: ::core::default::Default::default(),
                                port_destination: ::core::default::Default::default(),
                            }
                        }
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for Layer4Infos {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let mut __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "Layer4Infos",
                                    false as usize + 1 + 1,
                                )?;
                                _serde::ser::SerializeStruct::serialize_field(
                                    &mut __serde_state,
                                    "port_source",
                                    &self.port_source,
                                )?;
                                _serde::ser::SerializeStruct::serialize_field(
                                    &mut __serde_state,
                                    "port_destination",
                                    &self.port_destination,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[automatically_derived]
                    impl ::core::clone::Clone for Layer4Infos {
                        #[inline]
                        fn clone(&self) -> Layer4Infos {
                            Layer4Infos {
                                port_source: ::core::clone::Clone::clone(&self.port_source),
                                port_destination: ::core::clone::Clone::clone(
                                    &self.port_destination,
                                ),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::StructuralEq for Layer4Infos {}
                    #[automatically_derived]
                    impl ::core::cmp::Eq for Layer4Infos {
                        #[inline]
                        #[doc(hidden)]
                        #[coverage(off)]
                        fn assert_receiver_is_total_eq(&self) -> () {
                            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        }
                    }
                    #[automatically_derived]
                    impl ::core::hash::Hash for Layer4Infos {
                        #[inline]
                        fn hash<__H: ::core::hash::Hasher>(
                            &self,
                            state: &mut __H,
                        ) -> () {
                            ::core::hash::Hash::hash(&self.port_source, state);
                            ::core::hash::Hash::hash(&self.port_destination, state)
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::StructuralPartialEq for Layer4Infos {}
                    #[automatically_derived]
                    impl ::core::cmp::PartialEq for Layer4Infos {
                        #[inline]
                        fn eq(&self, other: &Layer4Infos) -> bool {
                            self.port_source == other.port_source
                                && self.port_destination == other.port_destination
                        }
                    }
                    trait PacketPorts {
                        fn ports(&self) -> Layer4Infos;
                    }
                    impl PacketPorts for TcpPacket<'_> {
                        fn ports(&self) -> Layer4Infos {
                            Layer4Infos {
                                port_source: Some(self.get_source().to_string()),
                                port_destination: Some(self.get_destination().to_string()),
                            }
                        }
                    }
                    impl PacketPorts for UdpPacket<'_> {
                        fn ports(&self) -> Layer4Infos {
                            Layer4Infos {
                                port_source: Some(self.get_source().to_string()),
                                port_destination: Some(self.get_destination().to_string()),
                            }
                        }
                    }
                    pub fn get_layer_4_infos(
                        proto: IpNextHeaderProtocol,
                        data: &[u8],
                    ) -> Layer4Infos {
                        match proto {
                            IpNextHeaderProtocols::Tcp => {
                                if let Some(tcp_packet) = TcpPacket::new(data) {
                                    tcp_packet.ports()
                                } else {
                                    Default::default()
                                }
                            }
                            IpNextHeaderProtocols::Udp => {
                                if let Some(udp_packet) = UdpPacket::new(data) {
                                    udp_packet.ports()
                                } else {
                                    Default::default()
                                }
                            }
                            IpNextHeaderProtocols::Icmp => {
                                if let Some(_icmp_packet) = IcmpPacket::new(data) {
                                    Default::default()
                                } else {
                                    Default::default()
                                }
                            }
                            IpNextHeaderProtocols::Icmpv6 => {
                                if let Some(_icmpv6_packet) = Icmpv6Packet::new(data) {
                                    Default::default()
                                } else {
                                    Default::default()
                                }
                            }
                            IpNextHeaderProtocols::Igmp => Default::default(),
                            IpNextHeaderProtocols::Ipv6Frag => Default::default(),
                            IpNextHeaderProtocols::Hopopt => Default::default(),
                            _ => {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "layer 4 - Unknown or unsupported packet type: {0}\n",
                                            proto,
                                        ),
                                    );
                                };
                                Default::default()
                            }
                        }
                    }
                }
                use layer_4_infos::{get_layer_4_infos, Layer4Infos};
                use serde::Serialize;
                pub struct Layer3Infos {
                    pub ip_source: Option<String>,
                    pub ip_destination: Option<String>,
                    pub l_4_protocol: Option<String>,
                    pub layer_4_infos: Layer4Infos,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Layer3Infos {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "Layer3Infos",
                            "ip_source",
                            &self.ip_source,
                            "ip_destination",
                            &self.ip_destination,
                            "l_4_protocol",
                            &self.l_4_protocol,
                            "layer_4_infos",
                            &&self.layer_4_infos,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Layer3Infos {
                    #[inline]
                    fn default() -> Layer3Infos {
                        Layer3Infos {
                            ip_source: ::core::default::Default::default(),
                            ip_destination: ::core::default::Default::default(),
                            l_4_protocol: ::core::default::Default::default(),
                            layer_4_infos: ::core::default::Default::default(),
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for Layer3Infos {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "Layer3Infos",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "ip_source",
                                &self.ip_source,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "ip_destination",
                                &self.ip_destination,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "l_4_protocol",
                                &self.l_4_protocol,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "layer_4_infos",
                                &self.layer_4_infos,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::clone::Clone for Layer3Infos {
                    #[inline]
                    fn clone(&self) -> Layer3Infos {
                        Layer3Infos {
                            ip_source: ::core::clone::Clone::clone(&self.ip_source),
                            ip_destination: ::core::clone::Clone::clone(
                                &self.ip_destination,
                            ),
                            l_4_protocol: ::core::clone::Clone::clone(
                                &self.l_4_protocol,
                            ),
                            layer_4_infos: ::core::clone::Clone::clone(
                                &self.layer_4_infos,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for Layer3Infos {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Layer3Infos {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        let _: ::core::cmp::AssertParamIsEq<Layer4Infos>;
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for Layer3Infos {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.ip_source, state);
                        ::core::hash::Hash::hash(&self.ip_destination, state);
                        ::core::hash::Hash::hash(&self.l_4_protocol, state);
                        ::core::hash::Hash::hash(&self.layer_4_infos, state)
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Layer3Infos {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Layer3Infos {
                    #[inline]
                    fn eq(&self, other: &Layer3Infos) -> bool {
                        self.ip_source == other.ip_source
                            && self.ip_destination == other.ip_destination
                            && self.l_4_protocol == other.l_4_protocol
                            && self.layer_4_infos == other.layer_4_infos
                    }
                }
                struct Ipv4Handler;
                struct Ipv6Handler;
                struct ArpHandler;
                struct VlanHandler;
                struct PppoeDiscoveryHandler;
                trait HandlePacket {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos;
                }
                impl HandlePacket for Ipv4Handler {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos {
                        if let Some(ipv4_packet) = Ipv4Packet::new(data) {
                            Layer3Infos {
                                ip_source: Some(ipv4_packet.get_source().to_string()),
                                ip_destination: Some(
                                    ipv4_packet.get_destination().to_string(),
                                ),
                                l_4_protocol: Some(
                                    ipv4_packet.get_next_level_protocol().to_string(),
                                ),
                                layer_4_infos: get_layer_4_infos(
                                    ipv4_packet.get_next_level_protocol(),
                                    data,
                                ),
                            }
                        } else {
                            Default::default()
                        }
                    }
                }
                impl HandlePacket for Ipv6Handler {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos {
                        if let Some(ipv6_packet) = Ipv6Packet::new(data) {
                            Layer3Infos {
                                ip_source: Some(ipv6_packet.get_source().to_string()),
                                ip_destination: Some(
                                    ipv6_packet.get_destination().to_string(),
                                ),
                                l_4_protocol: Some(
                                    ipv6_packet.get_next_header().to_string(),
                                ),
                                layer_4_infos: get_layer_4_infos(
                                    ipv6_packet.get_next_header(),
                                    data,
                                ),
                            }
                        } else {
                            Default::default()
                        }
                    }
                }
                impl HandlePacket for ArpHandler {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos {
                        if let Some(arp_packet) = ArpPacket::new(data) {
                            Layer3Infos {
                                ip_source: Some(
                                    arp_packet.get_target_proto_addr().to_string(),
                                ),
                                ip_destination: Some(
                                    arp_packet.get_target_proto_addr().to_string(),
                                ),
                                l_4_protocol: Default::default(),
                                layer_4_infos: Layer4Infos {
                                    port_source: None,
                                    port_destination: None,
                                },
                            }
                        } else {
                            Default::default()
                        }
                    }
                }
                impl HandlePacket for VlanHandler {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos {
                        if let Some(outer_vlan_packet) = VlanPacket::new(data) {
                            if outer_vlan_packet.get_ethertype() == EtherTypes::Vlan {
                                if let Some(inner_vlan_packet) = VlanPacket::new(
                                    outer_vlan_packet.payload(),
                                ) {
                                    let encapsulated_ether_type = inner_vlan_packet
                                        .get_ethertype();
                                    let encapsulated_data = inner_vlan_packet.payload();
                                    match encapsulated_ether_type {
                                        EtherTypes::Ipv4 => {
                                            Ipv4Handler::get_layer_3(encapsulated_data)
                                        }
                                        EtherTypes::Ipv6 => {
                                            Ipv6Handler::get_layer_3(encapsulated_data)
                                        }
                                        _ => Default::default(),
                                    }
                                } else {
                                    Default::default()
                                }
                            } else {
                                let encapsulated_ether_type = outer_vlan_packet
                                    .get_ethertype();
                                let encapsulated_data = outer_vlan_packet.payload();
                                match encapsulated_ether_type {
                                    EtherTypes::Ipv4 => {
                                        Ipv4Handler::get_layer_3(encapsulated_data)
                                    }
                                    EtherTypes::Ipv6 => {
                                        Ipv6Handler::get_layer_3(encapsulated_data)
                                    }
                                    _ => Default::default(),
                                }
                            }
                        } else {
                            Default::default()
                        }
                    }
                }
                impl HandlePacket for PppoeDiscoveryHandler {
                    fn get_layer_3(data: &[u8]) -> Layer3Infos {
                        if let Some(ethernet_packet) = EthernetPacket::new(data) {
                            if ethernet_packet.get_ethertype()
                                == EtherTypes::PppoeDiscovery
                            {
                                Layer3Infos {
                                    ip_source: None,
                                    ip_destination: None,
                                    l_4_protocol: Default::default(),
                                    layer_4_infos: Layer4Infos {
                                        port_source: None,
                                        port_destination: None,
                                    },
                                }
                            } else {
                                Default::default()
                            }
                        } else {
                            Default::default()
                        }
                    }
                }
                pub fn get_layer_3_infos(
                    ethernet_packet: &EthernetPacket<'_>,
                ) -> Layer3Infos {
                    match ethernet_packet.get_ethertype() {
                        EtherTypes::Ipv6 => {
                            Ipv6Handler::get_layer_3(ethernet_packet.payload())
                        }
                        EtherTypes::Ipv4 => {
                            Ipv4Handler::get_layer_3(ethernet_packet.payload())
                        }
                        EtherTypes::Arp => {
                            ArpHandler::get_layer_3(ethernet_packet.payload())
                        }
                        EtherTypes::Vlan => {
                            VlanHandler::get_layer_3(ethernet_packet.payload())
                        }
                        EtherTypes::PppoeDiscovery => {
                            PppoeDiscoveryHandler::get_layer_3(ethernet_packet.payload())
                        }
                        _ => {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "Layer 3 - Unknown or unsupported packet type: {0}\n",
                                        ethernet_packet.get_ethertype(),
                                    ),
                                );
                            };
                            Default::default()
                        }
                    }
                }
            }
            pub struct PacketInfos {
                pub mac_address_source: String,
                pub mac_address_destination: String,
                pub interface: String,
                l_3_protocol: String,
                pub layer_3_infos: Layer3Infos,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PacketInfos {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "PacketInfos",
                        "mac_address_source",
                        &self.mac_address_source,
                        "mac_address_destination",
                        &self.mac_address_destination,
                        "interface",
                        &self.interface,
                        "l_3_protocol",
                        &self.l_3_protocol,
                        "layer_3_infos",
                        &&self.layer_3_infos,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for PacketInfos {
                #[inline]
                fn default() -> PacketInfos {
                    PacketInfos {
                        mac_address_source: ::core::default::Default::default(),
                        mac_address_destination: ::core::default::Default::default(),
                        interface: ::core::default::Default::default(),
                        l_3_protocol: ::core::default::Default::default(),
                        layer_3_infos: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PacketInfos {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PacketInfos",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mac_address_source",
                            &self.mac_address_source,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mac_address_destination",
                            &self.mac_address_destination,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "interface",
                            &self.interface,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "l_3_protocol",
                            &self.l_3_protocol,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "layer_3_infos",
                            &self.layer_3_infos,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for PacketInfos {
                #[inline]
                fn clone(&self) -> PacketInfos {
                    PacketInfos {
                        mac_address_source: ::core::clone::Clone::clone(
                            &self.mac_address_source,
                        ),
                        mac_address_destination: ::core::clone::Clone::clone(
                            &self.mac_address_destination,
                        ),
                        interface: ::core::clone::Clone::clone(&self.interface),
                        l_3_protocol: ::core::clone::Clone::clone(&self.l_3_protocol),
                        layer_3_infos: ::core::clone::Clone::clone(&self.layer_3_infos),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for PacketInfos {}
            #[automatically_derived]
            impl ::core::cmp::Eq for PacketInfos {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Layer3Infos>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for PacketInfos {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.mac_address_source, state);
                    ::core::hash::Hash::hash(&self.mac_address_destination, state);
                    ::core::hash::Hash::hash(&self.interface, state);
                    ::core::hash::Hash::hash(&self.l_3_protocol, state);
                    ::core::hash::Hash::hash(&self.layer_3_infos, state)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PacketInfos {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PacketInfos {
                #[inline]
                fn eq(&self, other: &PacketInfos) -> bool {
                    self.mac_address_source == other.mac_address_source
                        && self.mac_address_destination == other.mac_address_destination
                        && self.interface == other.interface
                        && self.l_3_protocol == other.l_3_protocol
                        && self.layer_3_infos == other.layer_3_infos
                }
            }
            impl PacketInfos {
                pub fn new(
                    interface_name: &String,
                    ethernet_packet: &EthernetPacket<'_>,
                ) -> PacketInfos {
                    PacketInfos {
                        mac_address_source: ethernet_packet.get_source().to_string(),
                        mac_address_destination: ethernet_packet
                            .get_destination()
                            .to_string(),
                        interface: interface_name.to_string(),
                        l_3_protocol: ethernet_packet.get_ethertype().to_string(),
                        layer_3_infos: get_layer_3_infos(ethernet_packet),
                    }
                }
            }
            impl fmt::Display for PacketInfos {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                    f.write_fmt(
                        format_args!("MAC Source: {0}\n", self.mac_address_source),
                    )?;
                    f.write_fmt(
                        format_args!(
                            "MAC Destination: {0}\n",
                            self.mac_address_destination,
                        ),
                    )?;
                    f.write_fmt(format_args!("L2 Interface: {0}\n", self.interface))?;
                    f.write_fmt(format_args!("L 3 proto: {0}\n", self.l_3_protocol))?;
                    f.write_fmt(
                        format_args!(
                            "ip_source: {0}\n",
                            self.layer_3_infos.ip_source.as_deref().unwrap_or("N/A"),
                        ),
                    )?;
                    f.write_fmt(
                        format_args!(
                            "ip_destination: {0}\n",
                            self.layer_3_infos.ip_destination.as_deref().unwrap_or("N/A"),
                        ),
                    )?;
                    f.write_fmt(
                        format_args!(
                            "port_destination: {0}\n",
                            self
                                .layer_3_infos
                                .layer_4_infos
                                .port_destination
                                .as_deref()
                                .unwrap_or("N/A"),
                        ),
                    )?;
                    f.write_fmt(
                        format_args!(
                            "port_source: {0}\n",
                            self
                                .layer_3_infos
                                .layer_4_infos
                                .port_source
                                .as_deref()
                                .unwrap_or("N/A"),
                        ),
                    )?;
                    f.write_fmt(
                        format_args!(
                            "L 4 proto: {0}\n",
                            self.layer_3_infos.l_4_protocol.as_deref().unwrap_or("N/A"),
                        ),
                    )?;
                    Ok(())
                }
            }
        }
        use crate::tauri_state::SonarState;
        use self::layer_2_infos::PacketInfos;
        pub fn all_interfaces(app: tauri::AppHandle, state: State<SonarState>) {
            let mut handles = ::alloc::vec::Vec::new();
            let (tx, rx) = mpsc::channel::<PacketInfos>();
            let state_clone = state.0.clone();
            thread::spawn(move || {
                for packet in rx {
                    let mut vector = state_clone
                        .lock()
                        .expect("Failed to lock the mutex");
                    let found = vector.iter_mut().find(|(p, _)| *p == packet);
                    match found {
                        Some((_, count)) => *count += 1,
                        None => vector.push((packet, 1)),
                    }
                }
            });
            let interfaces = datalink::interfaces();
            for interface in interfaces {
                let app2 = app.clone();
                let tx_clone = tx.clone();
                let handle = thread::spawn(move || {
                    capture_packets(app2, interface, tx_clone);
                });
                handles.push(handle);
            }
            for handle in handles {
                match handle.join() {
                    Ok(_) => {}
                    Err(e) => {
                        ::std::io::_eprint(
                            format_args!("A thread panicked: {0:?}\n", e),
                        );
                    }
                }
            }
        }
        pub fn one_interface(
            app: tauri::AppHandle,
            interface: &str,
            state: State<SonarState>,
        ) {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("L\'interface choisie est: {0}", interface),
                        lvl,
                        &(
                            "sonar_desktop_app::sniff::capture_packet",
                            "sonar_desktop_app::sniff::capture_packet",
                            "src/sniff/capture_packet/mod.rs",
                        ),
                        57u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let (tx, rx) = mpsc::channel();
            let state_clone = state.0.clone();
            thread::spawn(move || {
                for packet in rx {
                    let mut vector = state_clone
                        .lock()
                        .expect("Failed to lock the mutex");
                    let found = vector.iter_mut().find(|(p, _)| *p == packet);
                    match found {
                        Some((_, count)) => *count += 1,
                        None => vector.push((packet, 1)),
                    }
                }
            });
            let interface_names_match = |iface: &NetworkInterface| {
                iface.name == interface
            };
            let interfaces = datalink::interfaces();
            let captured_interface = match interfaces
                .into_iter()
                .find(interface_names_match)
            {
                Some(interface) => interface,
                None => {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Aucune interface de ce type: \'{0}\'",
                                    interface,
                                ),
                                lvl,
                                &(
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "src/sniff/capture_packet/mod.rs",
                                ),
                                85u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Aucune interface de ce type: \'{0}\'",
                                interface,
                            ),
                        );
                    };
                }
            };
            capture_packets(app, captured_interface, tx);
        }
        fn capture_packets(
            app: tauri::AppHandle,
            interface: datalink::NetworkInterface,
            tx: mpsc::Sender<PacketInfos>,
        ) {
            let (_, mut rx) = match datalink::channel(&interface, Default::default()) {
                Ok(Ethernet(tx, rx)) => (tx, rx),
                Ok(_) => {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("Type de canal non géré : {0}", &interface),
                                lvl,
                                &(
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "src/sniff/capture_packet/mod.rs",
                                ),
                                100u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Type de canal non géré : {0}", &interface),
                        );
                    }
                }
                Err(e) => {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Une erreur s\'est produite lors de la création du canal de liaison de données: {0}",
                                    &interface,
                                ),
                                lvl,
                                &(
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "sonar_desktop_app::sniff::capture_packet",
                                    "src/sniff/capture_packet/mod.rs",
                                ),
                                104u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Une erreur s\'est produite lors de la création du canal de liaison de données: {0}",
                                e,
                            ),
                        );
                    }
                }
            };
            let main_window = app.get_window("main").unwrap();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "Démarrage du thread de lecture de paquets sur l\'interface :{0}",
                            &interface,
                        ),
                        lvl,
                        &(
                            "sonar_desktop_app::sniff::capture_packet",
                            "sonar_desktop_app::sniff::capture_packet",
                            "src/sniff/capture_packet/mod.rs",
                        ),
                        110u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            loop {
                match rx.next() {
                    Ok(packet) => {
                        if let Some(ethernet_packet) = EthernetPacket::new(packet) {
                            let packet_info = PacketInfos::new(
                                &interface.name,
                                &ethernet_packet,
                            );
                            if let Err(err) = main_window.emit("frame", &packet_info) {
                                {
                                    let lvl = ::log::Level::Error;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            format_args!("Failed to emit event: {0}", err),
                                            lvl,
                                            &(
                                                "sonar_desktop_app::sniff::capture_packet",
                                                "sonar_desktop_app::sniff::capture_packet",
                                                "src/sniff/capture_packet/mod.rs",
                                            ),
                                            117u32,
                                            ::log::__private_api::Option::None,
                                        );
                                    }
                                };
                            }
                            if let Err(err) = tx.send(packet_info) {
                                {
                                    let lvl = ::log::Level::Error;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            format_args!("Failed to send packet to queue: {0}", err),
                                            lvl,
                                            &(
                                                "sonar_desktop_app::sniff::capture_packet",
                                                "sonar_desktop_app::sniff::capture_packet",
                                                "src/sniff/capture_packet/mod.rs",
                                            ),
                                            120u32,
                                            ::log::__private_api::Option::None,
                                        );
                                    }
                                };
                            }
                        }
                    }
                    Err(e) => {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!("An error occurred while reading: {0}", e),
                                    lvl,
                                    &(
                                        "sonar_desktop_app::sniff::capture_packet",
                                        "sonar_desktop_app::sniff::capture_packet",
                                        "src/sniff/capture_packet/mod.rs",
                                    ),
                                    125u32,
                                    ::log::__private_api::Option::None,
                                );
                            }
                        };
                        break;
                    }
                }
            }
        }
    }
    use capture_packet::{all_interfaces, one_interface};
    use crate::tauri_state::SonarState;
    pub fn scan_until_interrupt(
        app: tauri::AppHandle,
        interface: &str,
        state: tauri::State<SonarState>,
    ) {
        match check_interface(interface) {
            true => all_interfaces(app, state),
            false => one_interface(app, interface, state),
        }
    }
    fn check_interface(interface: &str) -> bool {
        match interface {
            "Toutes les interfaces" => true,
            _ => false,
        }
    }
}
pub mod tauri_state {
    //! Module pour gérer l'état de Sonar.
    //!
    //! Ce module fournit les structures nécessaires pour maintenir l'état
    //! actuel de l'application Sonar, en particulier pour suivre les trames réseau.
    use std::sync::{Arc, Mutex};
    use crate::sniff::capture_packet::layer_2_infos::PacketInfos;
    /// `SonarState` encapsule l'état global de l'application Sonar.
    ///
    /// Cette structure est conçue pour stocker et gérer les informations sur les trames réseau
    /// capturées, y compris le comptage de leurs occurrences.
    ///
    /// # Structure
    /// `SonarState` contient un `Arc<Mutex<HashMap<PacketInfos, u32>>>`.
    /// - `Arc` permet un accès thread-safe et partagé à l'état.
    /// - `Mutex` garantit que l'accès à l'état est mutuellement exclusif,
    ///   empêchant les conditions de concurrence.
    /// - `HashMap<PacketInfos, u32>` stocke les trames réseau (`PacketInfos`) et
    ///   leur nombre d'occurrences (`u32`).
    ///
    /// # Exemple
    /// ```
    /// use std::sync::{Mutex, Arc};
    /// use std::collections::HashMap;
    /// use crate::capture_packet::layer_2_infos::PacketInfos;
    /// use crate::SonarState;
    ///
    /// let state = SonarState(Arc::new(Mutex::new(HashMap::new())));
    /// // Utilisez `state` ici pour gérer les trames réseau et leur comptage
    /// ```
    pub struct SonarState(pub Arc<Mutex<Vec<(PacketInfos, u32)>>>);
    impl SonarState {
        pub fn push_to_vector(&self, key: PacketInfos) {
            let mut vec = self.0.lock().expect("Failed to lock the mutex");
            if let Some((_, count)) = vec
                .iter_mut()
                .find(|(packet_info, _)| *packet_info == key)
            {
                *count += 1;
            } else {
                vec.push((key, 1));
            }
        }
    }
}
mod tests_unitaires {}
